#include "CppSerializer.h"

#include <cassert>
#include <vector>
#include <memory>
#include <algorithm>
#include <utility>
#include <set>

#include "Simulator.h"

#define INDENT "\t"

CppSerializer::CppSerializer(Model *model) :
_model(model) {
	assert(model != nullptr);
}

PersistenceRecord* CppSerializer::newPersistenceRecord() {
	return new PersistenceRecord(*_model->getPersistence());
}

static std::string indent(int times = 1) {
	std::string str = "";
	for (int i = 0; i < times; ++i) {
		str += INDENT;
	}
	return str;
}

bool CppSerializer::dump(std::ostream& output) {
	// prelude
	output << indent(0) << "/*\n";
	output << indent(0) << " * This C++ program was automatically generated by Genesys " + _model->getParentSimulator()->getVersion() + "\n";
	output << indent(0) << " * For your own safety, please review this file before compiling and running it.\n";
	output << indent(0) << " */\n";
	output << indent(0) << "\n";

	// gather parts in ID-order
	std::set<std::string> datadefs;
	std::set<std::string> components;
	std::set<std::string> typenames;
	std::vector<std::unique_ptr < PersistenceRecord>> parts;
	for_each([&](auto name) {
		if (name == "SimulatorInfo" || name == "Simulator" || name == "ModelInfo" || name == "ModelSimulation") return 0;
		auto fields = std::unique_ptr<PersistenceRecord>(newPersistenceRecord());
		get(name, fields.get());
		typenames.insert(fields->loadField("typename"));
		parts.push_back(std::move(fields));
		return 0;
	});

	// do includes and separate defs/components
	std::set<std::string> includes;
	for (auto& klass : *_model->getDataManager()->getDataDefinitionClassnames()) {
		if (!typenames.count(klass)) continue;
		datadefs.insert(klass);
		includes.insert("plugins/data/" + klass + ".h");
	}
	for (auto& comp : *_model->getComponents()->getAllComponents()) {
		if (!typenames.count(comp->getClassname())) continue;
		components.insert(comp->getClassname());
		includes.insert("plugins/components/" + comp->getClassname() + ".h");
	}
	output << indent(0) << "#include \"kernel/simulator/Simulator.h\"\n";
	for (auto& path : includes) {
		output << indent(0) << "#include \"" + path + "\"\n";
	}
	output << indent(0) << "\n";

	output << indent(0) << "int main(int argc, char** argv) {\n";
	output << indent(1) << "// instantiate simulator\n";
	output << indent(1) << "Simulator* genesys = new Simulator();\n";
	output << indent(1) << "genesys->getTracer()->setTraceLevel(TraceManager::Level::L9_mostDetailed);\n";
	output << indent(1) << "PluginManager* plugins = genesys->getPlugins();\n";
	output << indent(1) << "\n";
	output << indent(1) << "// create model\n";
	output << indent(1) << "Model* model = genesys->getModels()->newModel();\n";
	output << indent(1) << "// model->load(\"model.gen\")\n";
	output << indent(1) << "\n";

	output << indent(1) << "// initialize model parts\n";
	for (auto& var : parts) {
		std::string type = var->loadField("typename");
		Util::identification id = var->loadField("id", -1);
		std::string name = var->loadField("name", "_" + type + "_" + std::to_string(id));
		output << indent(1) // << (name.find(".") != std::string::npos ? "// " : "")
				<< type + "* " + name + " = plugins->newInstance<" + type + ">(model, \"" + name + "\");\n";
	}
	output << indent(1) << "\n";

	output << indent(1) << "// connect model components\n";
	ComponentManager* cm = _model->getComponents();
	for (auto& var : parts) {
		std::string type = var->loadField("typename");
		if (!components.count(type)) continue;
		Util::identification id = var->loadField("id", -1);
		ModelComponent *component = cm->find(id);
		if (component == nullptr) continue;
		std::string origin = component->getName();
		// 
		unsigned short nextSize = var->loadField("nexts", 1);
		for (unsigned short i = 0; i < nextSize; i++) {
			// target id
			Util::identification nextId = var->loadField("nextId" + Util::StrIndex(i), 0);
			if (nextSize == 1) nextId = var->loadField("nextId", static_cast<unsigned int> (nextId));
			// id -> component
			ModelComponent* nextComponent = cm->find(nextId);
			if (nextComponent == nullptr) {
				_model->getTracer()->traceError("found unregistered target ID " + std::to_string(nextId));
				return false;
			}
			// target port
			unsigned short nextPort = var->loadField("nextinputPortNumber" + Util::StrIndex(i), 0);
			// connect
			auto target = nextComponent->getName();
			output << indent(1) // << (origin.find(".") != std::string::npos || target.find(".") != std::string::npos ? "// " : "")
					<< origin + "->getConnections()->insert(" + target + ", " + std::to_string(nextPort) + ");\n";
		}
	}
	output << indent(1) << "\n";

	output << indent(1) << "// set simulation parameters\n";
	auto sim = _model->getSimulation();
	output << indent(1) << "ModelSimulation* sim = model->getSimulation();\n";
	output << indent(1) << "sim->setNumberOfReplications(1);\n";
	output << indent(1) << "sim->setReplicationLengthTimeUnit(Util::TimeUnit::" + Util::StrTimeUnitLong(sim->getReplicationLengthTimeUnit()) + ");\n";
	output << indent(1) << "sim->setReplicationLength(" + std::to_string(sim->getReplicationLength()) + ");\n";
	output << indent(1) << "sim->setReplicationReportBaseTimeUnit(Util::TimeUnit::" + Util::StrTimeUnitLong(sim->getReplicationBaseTimeUnit()) + ");\n";
	output << indent(1) << "\n";

	//output << indent(1) << "// serialize mod&sim state\n";
	//output << indent(1) << "model->save(\"model.gen\");\n";
	//output << indent(1) << "\n";

	output << indent(1) << "// run the simulation\n";
	output << indent(1) << "sim->start();\n";
	output << indent(1) << "\n";

	output << indent(1) << "// free memory\n";
	output << indent(1) << "delete genesys;\n";
	output << indent(1) << "\n";

	output << indent(1) << "return 0;\n";
	output << indent(0) << "}\n";

	return true;
}

bool CppSerializer::load(std::istream& input) {
	return false;
} // never

bool CppSerializer::get(const std::string& name, PersistenceRecord *entry) {
	assert(entry != nullptr);
	auto key = name == "Simulator" ? "SimulatorInfo" : name;

	auto it = _metaobjects.find(key);
	if (it != _metaobjects.end()) {
		entry->insert(it->second->begin(), it->second->end());
		return true;
	}

	it = _components.find(key);
	if (it == _components.end()) return false;
	entry->insert(it->second->begin(), it->second->end());
	return true;
}

bool CppSerializer::put(const std::string name, const std::string type, const Util::identification id, PersistenceRecord *fields) {
	// copy fields
	assert(fields != nullptr);
	auto saved = std::unique_ptr<PersistenceRecord>(this->newPersistenceRecord());
	saved->insert(fields->begin(), fields->end());

	// enforce consistency
	if (type == "") return false;
	auto unaliased = type == "Simulator" ? "SimulatorInfo" : type;
	saved->saveField("typename", unaliased);
	saved->saveField("id", id);

	// choose partition
	if (id == 0) {
		_metaobjects[unaliased] = std::move(saved);
	} else {
		if (id != 0) saved->saveField("name", name);
		_components[name] = std::move(saved);
	}

	return true;
}

int CppSerializer::for_each(std::function<int(const std::string&) > delegate) {
	// enfore id-order
	std::vector < std::pair<bool, std::string>> sorted;
	sorted.reserve(_metaobjects.size() + _components.size());
	for (auto& entry : _metaobjects) sorted.push_back({true, entry.first});
	for (auto& entry : _components) sorted.push_back({false, entry.first});
	std::sort(sorted.begin(), sorted.end(), [&](auto& a, auto& b) {
		if (a.first && b.first) { // both metatypes
			return this->_metaobjects.at(a.second)->loadField("id", 0) < this->_metaobjects.at(b.second)->loadField("id", 0);
		} else if (!a.first && !b.first) {
			return this->_components.at(a.second)->loadField("id", -1) < this->_components.at(b.second)->loadField("id", -1);
		} else /* different origins? metatypes < components */ {
			return a.first && !b.first;
		}
	});

	// then do the user-level iteration
	for (auto& e : sorted) {
		int stop = delegate(e.second);
		if (stop) return stop;
	}
	return 0;
}
